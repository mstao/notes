[TOC]

# 基础

## 方法签名

方法的输入参数


只有两列的二维矩阵：

表示一组数据对  

```
int[][] pairs;
// sort
Arrays.sort(pairs, (a, b) -> (a[0] - b[0]));
// sort int
Arrays.sort(pairs, Comparator.comparingInt(a -> a[0]));
```



Hash 记录的内容:

值 -> 索引



List: 

Java 中的 `add(index, val)`, `set(index, val)` 



**结构化，模板化，力求辅助读者培养框架思维，举一反三**


方法的返回值

返回 `LinkedHashMap`, 之后当成正常的 `Map` 使用

构造返回结果，通过 `StringBuilder` 进行拼接实现，通过 `char[]` 索引值注入实现


## 实现

找出反例，之后根据所有结果去除反例得到需呀的结果



keep track of minimum subarray



获取 `LinkedHashMap` 第一个元素

```java
int maxFreq = freqs.entrySet().iterator().next().getValue();
```



获取 `List` 第一个元素

> 用于获取 List 中存放元素的属性相同的值

```java
list.iterator().next();
list.get(0);
```


Map 的排序:

- `LinkedHashMap `排序

- `TreeMap` 排序

- `PriorityQueue` 放入 `Map.Entry` 进行排序



定义 `Tuple` 实现

保存 idx, val

保存 R, C, val


初始化数据集合

判断数据集合

往数据集合中存放元素

根据条件删除数据集合中的元素





一个数据结构的性质操作:

增删改查

反转

交换

查找

合并

结果性质： 是否有环、是否是 BST、是否是回文





额外的操作：

排序： 对应 Comparator

分割： 

合并：

复制： 对应 clone

构建： 对应 Builder, Adapter...


## 分类

扁平嵌套迭代器

ArrayList 的迭代

LinkedList 的迭代 

PriorityQueue 的迭代，借助 `ArrayDeque` 实现



# 其他


## 数学

素数

公约数

进制转换

阶乘

平方数

乘积数组





Java 中相关的方法

```java
public String convertToBase7(int num) {
    return Integer.toString(num, 7);
}
```


# Other
子数组
连续子数组和
连续子数组乘积

子序列
二维矩阵
双指针处理， 用于找kth数，用于找子数组的边界，记录滑动窗口

### 滑动窗口处理思路
从初始位置，逐渐向外扩散
随着求的条件进行不断的扩散或者缩小
整体上 L, R 的边界会不断的增加


滑动窗口的初始值 L=0, R= -1
滑动窗口的推出条件  L < N


滑动窗口的初始值 L=0, R= -1
滑动窗口的推出条件  L < N


局限性:
对于 负值不好处理


### HashTable 问题
初始的时候统计词频
在迭代的过程中统计词频
记录 index->val，或是 val->index


关键点:
定义要找的条件 Key

=> 为原始数据添加额外的属性
=> 基于原始数据获取额外的信息



特殊的存储情况：
随迭代器不断比较和放入数据
记录第一次出现的数据
记录最后一次出现的数据


对 Map 的 Entry 进行排序
使用 TreeMap 进行排序以及处理 floorKey,ceilingKey


考虑的极端情况:
是否排序
根据条件筛选出来的数据是否可能重复



问题类型:
找最值问题
找出一个满足条件的值
找出所有满足条件的可能性
找出所有满足条件的相关数据


使用数组来表示Map:
数据中的元素都是数字，且范围在 [0,n-1]
数组中的元素是字符


### 初始值的设置
通过 Map 收集出需要的初始值
最值的初始值，为对应相反的最值


### 双指针处理
初始值
循环判断条件
加速指针的跳转
作为缩减问题规模的情况




为了满足条件，一般对原始数据进行排序，保证指针 ->, <- 方向的相反性
基于双指针的三元祖、四元祖问题


### 矩阵问题
矩阵中的路径
矩阵中的可能性
矩阵中的边、面积等问题


### 空间
**防止覆盖问题**
空间节省
可以更改传入的数据，可以按照特定的顺序进行覆盖，之后要判断的数据不会被之前的覆盖参数所影响



变更原始数据，造成之后的判断条件无效
==> 记录原始的数据(clone)



**防止重复计算问题**
对传入的数进行取模
动态规划








使用临时变量随着迭代进行保存特定值
与当前迭代元素差一个元素，之前所有元素的乘积
与当前迭代元素差一个元素，之后所有元素的乘积


### 二分查找


二分查找用于范围查询，相当于为每个数添加一个属性，小于等于该数的总个数
旋转有序无重复元素数组查找指定的元素
旋转有序有重复元素数据查找指定的元素

按照特定规格有序的二维矩阵查找指定的元素


### 顺序类问题
包含部分的最值问题


### 方法定义
返回值的特殊性，对于数组的索引，是否是从 zero 开始


### 字符串
同构字符串  

  

  


## 其他
存放数字:  
使用 array 存放数字  
使用 String 存放数字  
使用 listNode 存放数字  

  

  

List、Queue 中保存空元素，之后的迭代过程中判断  
在保存之前判断是否之后的迭代过程中使用到的内容是空的  

  

  

数据结构之间的转换:  
ListNode => BST  
Array    => BST  
BST      => double side chain table    

  

原始数据处理:  
为原始数据增加 "伪属性", 通过 Map 记录词频，记录每个节点的高度，记录每个节点的父节点  
对原始数据排序，方便双指针的处理，对于字符串数组排序，方便找出迭代的规律性质  
对字符串进行去除无效空字符, trim，忽略 null/""/blank 值    

  


找通用的解法，通用的数据结构处理  

  