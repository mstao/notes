# 基础

## 对象关系

**组合和继承**

**聚合和组合**

聚合是一种强的关系，类似于 公司与部门；

（2） 组合 

组合是一种弱的关系，





## 设计原则

**SOLID**

**单一职责**

开闭原则

里氏替换原则

接口隔离原则

依赖反转原则







关联关系：  

   


依赖关系：  
OOP中双向依赖关系被人为是不好的设计    




扩展关系:  
> 用在概念用例模型中  

用例的某一部分是可选的/可能的系统行为 
只有再特定的情况下，才执行分流，如触发警告  
多个基本用例中都可
能触发一个可选的分支流，可代表多个用例的可复用部分  

```  
 <<extend>>
- - - - - - ->
```

  

包含关系

```
 <<include>>
- - - - - - - ->
```

  


实现关系：  
```
- - - - - -|>
```

  

  


SOA:(Service Oriedted Archiecture): 面向服务的架构  



**puml** 

借助文本的方式绘制 UML 图形  


非具体代码，  讲解，  隐性

博士论文

设计建模

语言限制

更多的模式：   并发模式、架构模式  (系统架构层面)



5.2 变继承关系为组合关系

继承关系  is-a要求高,  现实中不易出现;

protected实现继承的局限性;

​       |-单根继承

设计模式能够提供更好的实现， 具有高复用性.

 

**试题**一**：**  如何将employee   -->  Manager  ?    

​       |-新建一个，  换掉原来的引用(在Employee & Manager不可变)



通过组合构造,  即通过接口进行不同的实现,  通过set()实现升职情况， 使其方法行为对应不同的改变。

​       |-通过改变Role来改变其行为

public class Employee{

​    **private Role role;**[[J12\]](#_msocom_12) 

​    ...

​    public void doWork(){

role.doWork();

}

}

public interface Role{

​    void doWork();

}

public class Manager implements Role{

​    public void doWork(){ ... }

}

public class Engineer implements Role{

​    public void doWork(){ ... }

}

 

Runnable接口

试题二： 如何实现LoggingRunnable，  TransactionRunnable接口？

 

Exception处理，  将编译型当做运行时抛出

throw new RunnableException(e);

 

方式一： 继承方式实现

doRun() | innerRun() | realRun()

​       |-将实现对应的逻辑代码放到run()中

​       |-将根据不同业务情况的代码写到doRun()中

​       |-类的层次结构为  interface --> abstract class --> class

public abstract class LoggingRunnable implements Runnable {

​    **protected abstract** void doRun();

​    public void run(){

long startTime = System.currentTimeMillis();

System.out.println(“Task started at ” + startTime);

doRun();

System.out.println(“Task finished. Elapsed time: ”

\+ (System.currentTimeMillis() – startTime ));

}

}

public abstract class TransactionRunnable implements Runnable {

​    **protected abstract** void doRun();

​    public void run() {

​       **boolean isShouldRoll = false;**[[113\]](#_msocom_13) 

try{

​    beginTransaction();

​    **doRun();**

}catch(Exception e){

​    isShouldRoll = true;

​    throw e;

} finally{

​    if(isShouldRoll){ rollback(); }

​    else { commit(); }

}

}

}

public class CodingTask extends TransactionRunnable {

​    protected void doRun(){

​       System.out.println(“Wring code.”);

}

}

 

无法同时实现LoggingRunnable， TransactionRunnable?

​       且不容易控制两者的执行顺序



方式二：  

### Decorator Pattern

​       |-类的层次结构    接口   组合各个不同的实现类(接口类型)   

​       |-多重装饰特性：  可有多重嵌套特性,  策略性强， 耦合性低     



 

**好处：** 多层嵌套实现,  调用顺序控制

​       |-new LoggingRunnable(

​              new TransactionRunnable(

​                     new CodingRunnnable()))

在哪儿使用过Decorator Pattern？  解决了什么问题[[114\]](#_msocom_14)  ？

在构建自定义连接时， 使用Decorator Pattern对其中的close()方法进行加强

​       |-进行重写加强的方法， 可使用已经传递过来的Connection,

|-将close()行为改成将连接放到定义的List<Connection> pool中

​       |-一般性的方法使用传递过来的Connection组合调用

 

I/O流采用装饰者设计模式，如new BufferedInputStream(new FileInputStream(path))



  

## 如何创建对象

### Abstract Factory Pattern

|-编译期不需知道创建对象的参数

|-如线程池的创建Executor.newFixedThreadPoll(xx)

|-相较于构造器this之间调用更灵活、语义更明确



### Builder Pattern

|-根据情况进行构建，可直接依据已经存在的

|-解决参数意义不明确的问题(具备方法name属性)

**|-****与不可变类型进行协作**





# 创建型(5)

## 简单工厂

**基本特性**

**（1） 好处**

一个变量即可获得想要的实例





**（2） 缺点**

① 需要修改工厂的逻辑，总是

② 无法实现继承的等级结构



**反射扩展**

通过反射弥补简单工厂的扩展性

当我们需要新增一门新的课程时，就需要修改工厂类的实现；



**源码中的使用**

（1） DriverManager

注册对应的驱动实现

2） LoggerFactory

## 工厂方法

**基本**

定义一个创建对象的接口，只定义规范、契约，不决定产生哪种类的实现。

核心： 将类的实例化推迟到子类中进行；  工厂有不同的层次；能够使用到继承特性；



需要构建多个工厂类，用其实现定义的工厂接口。

（） 优点

只需关心所需产品对应的工厂



（2） 缺点

由子类进行实例化，可能造成类的个数过多



（） 适用范围

解决统一产品等级的业务抽象问题



**与简单工厂的区别**

（） 产品等级

产品相同，品牌可能不同，美的的冰箱、格力的冰箱、海尔的冰箱

（） 产品族

美的的冰箱、美的的洗衣机、美的的空调





**源码实现**

（1） Collection 中 Iterator

提供多种迭代器；

（2） ILoggerFactory



（3） URLStreamHandlerFactory

用于解决 URL 协议扩展使用



（） ReentrantReadWriteLock

```java
Lock writeLock();
Lock readLock();
```



## *抽象工厂

一个产品族

创建  一系列相关或相互依赖对象的  接口，  无需指定他们具体的类

核心： 将一系列的产品族统一到一起创建



将统一

（） 产品族

同一个产品下的各种不同类型的产品，美的的空调、美的的冰箱、美的的洗衣机。。。

Python 的手记、 Python 的视频、 Python 的介绍。。。



**与工厂方法的比较**

工厂方法针对的是产品等级结构；

抽象工厂模式针对的是产品族。

**源码实现**

（1） Connection

preparedStatement

Statement

CallableStatement

（2） SqlSessionFactory (m)



## *建造者

处理流程固定，而顺序不固定的情况



**源码实现**

（） 适用场景

一个对象有非常负载的内部结构，多个属性( map 作为扩展字段使用)

将复杂对象的   创建和使用分离

（） 优点

扩展性好，一定程度上解耦



（） 缺点
产生多余的 Builder 对象



与工厂模式区别

更注重顺序；





**源码实现**

（1） StringBuilder

（2） Guava 中对于缓存的构建

构建初始容量、最大使用大小、过期时间、并发等级进行控制

（3） Guava 中不可变容器的构造

配合的是对应的静态构建方法实现，获取到构建器之后不断构建；

通过 deprecated 来进行提醒，防止调用修改结构；

```java
final static ImmutableMap<Integer, Integer>  map  = ImmutableMap.<Integer, Integer>builder()
            .put(1, 2).put(2, 3).put(3, 4).build();
```

 ImmutableSet

add

of

copyOf(coll)



通过不断的 add 来实现

实现的项目中 EventModel 类似，通过内部组合一个 Map 作为一个扩展字段从而实现

） BeanDefinitionBuilder(S)

（） SqlSessionFactoryBuilder

（） EventModel

（） Jedis 中关于 scan 命令中参数的构建

内部维护着一个 EnumMap 来对应有限的命令；



## *单例模式

介绍： 代表仅仅被实例化一次的类；通常用来代表那些本质上唯一的系统组件；



7 种单例模式： 懒汉模式线程不安全、懒汉模式线程安全、饿汉模式、
变种的饿汉模式、双重校验锁DCL、静态内部类、枚举类型



通用的考虑：

私有的构造；

注意线程安全问题；

防范序列化；

防范反射攻击；

防范克隆；



延迟加载；





单例模式总结：三个组成

- 私有(private)静态(static)的单例对象

- 构造函数(struct)，     --可在构造函数初始化单例对象

- 对外(public) ,        静态方法获得单例对象





**饿汉式**

在类初始化时，直接持有，不会出现线程安全问题

```java
public class HungrySingleton {

    // also can StaticBlock
    private static HungrySingleton instance = new HungrySingleton();

    private HungrySingleton() {}

    public static HungrySingleton getInstance() {
        return instance;
    }
}
```



**懒汉式-线程安全**

```java
public class SynchronizedSingleton {

    private SynchronizedSingleton() {
        // prevent reflection
        if (instance != null)
            throw new UnsupportedOperationException();
    }

    private static SynchronizedSingleton instance = null;

    public static synchronized SynchronizedSingleton getInstance() {
        if (instance == null) {
            instance = new SynchronizedSingleton();
        }
        return instance;
    }

    // reduce lock size
    // if (condition(a)) handle(a)
    public static SynchronizedSingleton getInstanceV() {
        synchronized (SynchronizedSingleton.class) {
            if (instance == null) {
                instance = new SynchronizedSingleton();
            }
        }
        return instance;
    }
}
```



**懒汉式-双重监测锁**

在一些低版本的JDK还不能够保证执行的正确性， JDK5 之前未增强 volatile 的语义；

volatile 解决了 Object obj = new Object(); 时发生的指令重排序问题；

```java
class DCLSingleton {

    private DCLSingleton() {}

    private static volatile DCLSingleton instance = null;

    public static DCLSingleton getInstance() {
        if (instance == null) {
            synchronized (DCLSingleton.class) {
                instance = new DCLSingleton();
            }
        }
        return instance;
    }
}
```





**懒汉式-内部持有**

1、可以实现延迟加载的功能，只有在调用getInstance（）的方法才会创建单例对
象，并且是通过类加载器机制保证值创建一个单例对象；
2、JVM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会执行类的
初始化。在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对
同一个类的初始化。
3、对于Java类加载机制来说，当第一次访问类的静态字段的时候，会触发类加载，
并且同一个类只加载一次。静态内部类也是如此，只会被加载一次，类加载过程由类
加载器负责加锁，从而保证线程安全。

```java
public class SICSingleton {

    private static class InstanceHolder {
        private static final SICSingleton instance = new SICSingleton();  // use final
    }

    private SICSingleton() {
        if (InstanceHolder.instance != null) {
            throw new RuntimeException("Singleton constructor Disable reflection calls.");
        }
    }

    public static SICSingleton getInstance() {
        return InstanceHolder.instance;
    }
}
```



**懒汉式-Enum 实现**

可以防御反射和序列化攻击；

无偿地提供了序列化机制，绝对防止多次实例化；

```java
public enum EnumSingleton {
    INSTANCE{
        protected  void printTest(){
            System.out.println("Geely Print Main");
        }
    };

    // need to override
    protected abstract void printTest();

    private Object data;

    public Object getData() {
        return data;
    }

    public void setData(Object data) {
        this.data = data;
    }

    public static EnumSingleton getInstance(){
        return INSTANCE;
    }
}
```



**单例的破坏**

（1） 破坏的情况

反射、序列化





（2） 一定的防御措施

单例的







**&懒汉式与饿汉式区别？**
从名字上来说，饿汉和懒汉，
饿汉就是类一旦加载，就把单例初始化完成，保证getInstance的时候，单例是已经存在的了，
而懒汉比较懒，只有当调用getInstance的时候，才回去初始化这个单例。
另外从以下两点再区分以下这两种方式：

1、线程安全：
饿汉式天生就是线程安全的，可以直接用于多线程而不会出现问题，
懒汉式本身是非线程安全的，为了实现线程安全有几种写法，分别是上面的1、2、3，这三种实现在资源加载和性能方面有些区别。

2、资源加载和性能：
饿汉式在类创建的同时就实例化一个静态对象出来，不管之后会不会使用这个单例，都会占据一定的内存，但是相应的，在第一次调用时速度也会更快，因为其资源已经初始化完成，
而懒汉式顾名思义，会延迟加载，在第一次使用该单例的时候才会实例化对象出来，第一次调用时要做初始化，如果要做的工作比较多，性能上会有些延迟，之后就和饿汉式一样了。



**适用范围**

构造缓慢的资源

​       |-BeanFactory



使用与统一管理的资源

​       |-线程池

​       |-连接池

共用造成的改变， 不易于复用

![img](file:///E:/Data/Wiz/My Knowledge/temp/f1782ca9-fd09-4d8c-b2b8-de5aef6ac117/128/index_files/image073.jpg)

 

**创建的方式**

懒汉双重锁  -->  创建冲突(初始化慢)    -->   框架提供的能力(Spring…)

![img](file:///E:/Data/Wiz/My Knowledge/temp/f1782ca9-fd09-4d8c-b2b8-de5aef6ac117/128/index_files/image074.jpg)





懒汉与饿汉？？

饿汉：  穷， 不给准备行， 担心饿死，  类加载就准备好

​       |-添加final关键字进行优化，  更为严谨



懒汉式(饱汉式)： 延迟加载，   有钱， 用的时候再new

​       |-不可为final ，   存在初始化问题,   需要在工厂方法中另外赋值

​              |-只能在static域、构造器、定义时初始化, 因而



双重锁：  同步内容放在if内部， 提高执行的效率， *不必每次获取对象时都进行同步。*

​       **|-****静态方法同步的时候，** **使用的锁，** **不能是this****，** **而是类.class**

​       **|-volatile****关键字，** **保证变量的可见性**



**相关问题：**

*a )* *双重锁为什么提高了效率？*  *其执行情况是什么样的流程？*

假设第一次A线程走到这，然后，呈挂起状态。这个时候，单例对象还未创建；假设此时，B线程也来了判断单例对象==null成立，但是，因为A线程已经给里层的if判断上锁，所以，B只能在外等着。

假设A线程被唤醒，那么，单例就会下面语句赋值，单例对象就创建啦。然后释放锁。B就可以进来啦。  B线程进来之后，先判断单例对象是否为null，发现已经不是null啦，那么就不需要创建啦。

CD线程同样， *再往后面来的，第一个if**就进不来啦，那就不会判断锁了。*

 

*b )* *懒汉式与饿汉式的优缺点？*  *比较他们之间的区别？*

时间和空间：  懒汉式是典型的时间换空间，也就是每次获取实例都会进行判断，看是否需要创建实例，浪费判断的时间。当然，如果一直没有人使用的话，那就不会创建实例，则节约内存空间。

饿汉式是典型的空间换时间，当类装载的时候就会创建类实例，不管你用不用，先创建出来，然后每次调用的时候，就不需要再判断了，节省了运行时间。

线程安全：  不加同步的懒汉式是线程不安全的，比如，有两个线程，一个是线程A，一个是线程B，它们同时调用getInstance方法，那就可能导致并发问题。

*饿汉式是线程安全的，因为虚拟机保证只会装载一次，在装载类的时候是不会发生并发的。*

 

**源码**

（1）Spring 中的单例



## 原型模式

通过 拷贝 这些原型创建新的对象，与 Spring 中的 prototype



必须 clone 方法



使用场景



（） 优点

性能比 new 对象高；

简化创建过程，无需进行参数指定，直接使用原型的进行构建；

（）注意点

深克隆

浅克隆



**与单例模式**

通过反射调用 clone 方法



**源码**

（1） 大部分的容器的 clone 方法

（2） CacheKey(M)





Q: clone 对象中有 Enum 类如何处理

Q: Clone 与 new 的性能比较

性能取决于 clone 方法和 construct 中的内容，而不是使用的 new、clone 本身





Java中clone( )和new效率比较

https://blog.csdn.net/iblade/article/details/80749148









# 结构型(7)

## *装饰者模式

特性：  动态地扩展原有对象功能



使用情况： 

解决 Web 中的编码问题，增强的 EnhanceRequest，为其实现了对于编码的转换，同时将其 getRequestParamMap 来实现



（） 扩展功能的方式

代理模式

装饰者模式

继承

反射？？



**与代理模式的比较**

代理模式关注与 控制对对象的访问，代理类可以对客户隐藏对象的具体信息；



**源码**

（1） IO 流

BufferedInputStream





定义：

- 在不改变原有对象的基础之上，将功能附加到对象上
- 提供了比继承更有弹性的替代方案（【扩展原有对象】功能）

适用场景 ： 

- 扩展一个类的功能或给一个类添加咐加职责
- 动态的给一个对象添加功能，这些功能可以再【动态】的撤诮

优点 ： 

- 继承的有力补充，比继承灵活，不改变原有对象的情况下给一个对象扩展功能
- 通过使用不同装饰类以及这些装饰类的排列组合，可以实现不同效果
- 符合开闭原则

缺点 ： 

- 会出现更多的代码，更多的类，增加程序复杂性
- 动态装饰时，多层装饰时会更复杂

组合多个对象，排查错误复杂

### 比较

相关模式的比较： 
 装饰者与代理模式的比较 ： 
 关注点 :  装饰者关注在对象上动态地添加方法，代理模式关注于【控制对对象的访问】，代理类可以对其客户隐藏对象的具体信息 
 使用上 : 装饰者模式通常将原始对象作为一个【参数传递】给装饰者的构造器 
 代理模式通常在代理类中【创建】一个对象的实例

装饰者与适配器模式的比较： 
 同为 包装模式 
 适配器和适配的类具有不同的接口，或者说是抽象级别

装饰者扩展与继承扩展的比较： 
 使用继承实现功能扩展 ： 必须可预见扩展功能， 功能在编译时便确定了，属于静态 
 通过装饰者，包装 Target，在其执行前后加上自己的逻辑，或者直接不使用包装的逻辑，运行时随用户自己组装动态的扩展

### 应用

煎饼，加了一个煎饼的 
 加蛋的煎饼

2 个鸡蛋，  3 根香肠的组合

抽象的实体类 :  
 确定的实体类 : 

抽象的装饰者 : 
 确定的装饰者 : 包装抽象的实体类

支持多次装饰同一个

旅行订单 
 旅行保险 
 使用保险装饰订单

**好处：** 多层嵌套实现, 调用顺序控制

|-new LoggingRunnable(

new TransactionRunnable(

new CodingRunnnable()))

在哪儿使用过Decorator Pattern？ 解决了什么问题[[114\]](#_msocom_14) ？

在构建自定义连接时， 使用Decorator Pattern对其中的close()方法进行加强

|-进行重写加强的方法， 可使用已经传递过来的Connection,

|-将close()行为改成将连接放到定义的List pool中

|-一般性的方法使用传递过来的Connection组合调用

I/O流采用装饰者设计模式，如new BufferedInputStream(new FileInputStream(path))

日志装饰、事务装饰功能的增强

 

```
public class LoggingRunnable implements Runnable {
    private final Runnable innerRunnable;

    public LoggingRunnable(Runnable r){ this.innerRunnable = r; }

    public void run(){
        long startTime = System.currentTimeMillis();
        System.out.println(“Task started at ” + startTime);
        innerRunnable.run();
        System.out.println(“Task finished. Elapsed time: ”
        + (System.currentTimeMillis() – startTime ));
    }
}

public class TransactionRunnable implements Runnable {

privte final Runnable innerRunnable;

public TransactionRunnable(Runnable r) { this.innerRunable = r; }

public void run() {

boolean isShouldRoll = false;

try {
    beginTransaction();
    innerRunnable.run();
} catch (Exception e) {
    isShouldRoll = true;
    rollBack();
} finally {
    if(isShouldRoll){
    rollBack();
    } else {
    commit();
    }
}
}
}
```

### 源码应用

Java IO   JDK 
 BufferedReader： 为普通的 Reader 增加缓冲功能 
 BufferedInputStream： 同上 
 FilterInputStream ： 为装饰者， 





## *适配器模式

适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。





处理原本接口不兼容的类可以一起工作

一种维护软件的手段

实现了对现有类的复用；





定义：将一个类的接口转换成客户期望的另一个接口 
使原本接口不【兼容】的类可以一起工作

适用场景 ：

- 已经存在的类，它的方法和需求不匹配时（方法结果相同或相似）
- 不是软件设计阶段考虑的设计模式，是随着软件【维护】，由于不同产品、不同厂家造成功能类似而接口不相同情况下的解决方案

优点 ：

- 能提高类的透明性和复用，现有的【类复用】但不需要改变
- 目标类和适配器类解耦，提高程序扩展性
- 符合开闭原则

缺点 ：

- 适配器编写过程需要全面考虑，可能会增加系统的复杂性
- 增加系统代码可读的难度

扩展 ：

- 对象适配器 ： 符合组合复用原则，使用委托机制
- 类适配器 ： 通过类继承实现

相关模式 ： 
与外观模式 ： 都是对现有的类或现有的系统的封装， 
外观模式定义了新的接口 
适配器复用原有的接口，使两个已有的接口协同工作 
外观模式在现有的系统中，提供一个更为方便的访问入口

适配粒度 ： 外观适配整个子系统 
适配器

### 类适配器

被适配者 ： 
抽象的目标 ： 
具体的目标 ： 
适配者 ： 继承被适配者，实现目标接口

Target 接口的具体实现通过 Adapter 移交给 被适配者 Adaptee 







### 对象适配器

被适配者 和 目标 不变 
通过对象关联的方式进行组合调用

通过组合 把具体实现 Target 的 request 方法委托给被适配者 Adaptee 





收集电池的适配器 
220 V 交流电 转换成哼 5V 的直流电

### 源码应用

XMLAdapter

AdvisorAdapter 
适配成 MethodInterceptor

JPAVendorAdapter 
Spring JPA 
AbstractJpaVendorAdapter 
Database 
DB2 
Derby 微型数据库 
H2 内存数据库

HandlerAdapter 
Spring mvc 
DispatchServler

- doDispatch( 
  Controller 
  通过适配器使每一个 Controller 的实现都能找到对应的适配器实现类 ，使适配器执行相应的方法 
  在扩展 Controller 时增加一个适配器类便可完成 Spring mvc 的扩展

DispatcherServlet.getHandlerAdapter(handler) 
对每一个 handler 返回对应的 HandlerAdapter 
SimpleControllerHandlerAdapter







## 代理模式

控制对于某个对象的访问；

在客户端和目标对象之间起到中介的作用；





**代理的分类**

（1） 动态代理

基于接口实现的





（2） CGLIB 代理

基于继承实现的



（3） Spring 中的代理

优先选择 动态代理，再需要代理的目标类没有实现方法时，使用 CGLIB 代理。



**适用场景**

代理模式的应用场景：

如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：

1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。

2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。

使用代理模式，可以将功能划分的更加清晰，有助于后期维护！



**源码**







> 定义：为其他对象提供一种代理，以【控制对这个对象的访问】 
> 代理对象在客户端和目标对象之间起到中介的作用

增加功能

SPring AOP 
before : 草拟合同 
after : 水电费结算 
目标方法 ： 租房子

适用场景 ：

- 保护目标对象
- 增强目标对象 
  代理模式的应用场景： 
  如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法： 
  1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。 
  2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。 
  使用代理模式，可以将功能划分的更加清晰，有助于后期维护！

优点 ：

- 代理模式能将代理对象与真实被调用的目标对象分离
- 一定程度上降低了系统的耦合度，扩展性好
- 保护目标对象
- 增强目标对象

缺点 ：

- 代理模式会造成系统设计中类的数目增加
- 在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢
- 增加系统的复杂度

扩展 ： 
静态代理 ： 
动态代理 ： 通过接口中的方法名在动态生成的代理类中调用业务实现类的同名方法 
JDK 中的代理只能对实现接口的类进行代理，无法针对一个具体的实现类；只能代理接口中的方法，具体实现类中多余方法无法代理 
CGLib 代理 ： 基于继承，针对类实现进行代理，无法实现 final class，和对于 final 方法

扩展 - Spring 代理选择 ： 
当 Bean 有实现接口时，Spring就会用JDK的动态代理 
当 Bean 没有实现接口时，Spring使用CGIib 
可以强制使用 CGLib 代理 
在spring配置中加入 
参考资料 https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html

扩展 - 代理速度对比 ： 
CGLib : asm 字节码生成，相对反射效率高 
Dynamic Proxy : 
W 次， JDK7,8 比 CGLib 快 20%

相关模式 ： 
与装饰者模式 ： 实现相似 
装饰者为对象加上行为， 
代理模式为控制访问，通过设置代理人的方式来增强目标对象，一般增强目标对象的某些行为

与适配器模式 ： 
适配器模式主要改变锁考虑对象的接口 
代理模式无法改变所代理类的接口

### 静态代理

分库方式 
spring 
BeforeAdvice 
AfterAdvice

AbstractRoutingDataSource

- targetDataSources :Map 





### 动态代理

动态代理根据 class 动态生成，静态代理显示的描述

Proxy.newProxyInstance(classloader, Class[], invocationHandler)

- Constructor

InvocationHandler.invoke

- proxy : 少用，动态代理类，动态生成的，可对其进行持久化，通过反编译查看代码
- method
- args

### 源码应用

java.lang.reflect.Proxy

ProxyFactoryBean 
spring 核心类

- getObject()

JdkDynamicAopProxy 
aop 包下，对 JDK 动态代理进行封装

CglibAopProxy 
对类进行代理增强

MapperProxyFactory 
mybatis

- newInstance(sqlSession) 
  MapperMethod.execute



## 外观模式(门面)

**源码**

（1） tomcat 中各种的门面

RequestFacade

ResponseFacade

StatementFacade



> 门面模式 
> 定义：又叫门面模式，提供了一个统一的接口，用来访问子系统中的一群接口 
> 外观模式定义了一个高层接口，让【子系统】更容易使用

适用场景 ： 
子系统越来越复杂，增加外观模式提供简单调用接口 
构建多层系统结构，利用外观对象作为每层的入口，简化层间调

优点 ：

- 简化了调用过程，无需了解深入子系统，防止带来风险。
- 减少系统依赖、松散耦合
- 更好的划分【访问层次】
- 符合【迪米特法则】，即最少知道原则

缺点 ：

- 增加子系统、扩展子系统行为容易引入风险
- 不符合开闭原则

相关模式 ： 
中介者模式 ： 外观模式关注外界和子系统之间的交互，中介者模式关注子系统之间的交互 
单例模式 ： 可以将外观模式中的外观对象做成单例模式结合使用 
抽象工厂模式 ： 外观类通过抽象工厂获取子系统的实例，实现子系统对外观类的屏蔽

作为系统对外的入口 
Tomcat 中常使用该种模式





### 应用

需求 ： 积分兑换 
资格校验，礼物的库存校验，积分校验 
积分支付子系统 
对接物流系统

对外提供礼物兑换的外观类将这些逻辑封装起来

拆分作为 RPC 服务，对外提供三个服务 
子系统之间的调用逻辑

Set 注入 
未集成 Spring， 通过 set 方式注入



Spring 注入 
模拟集成 Spring， 通过 DI 注入 





应用层是否与子系统之间发生交互】，检验外观模式 
新增子系统，违背 开闭原则

实体外观类 ： 适用于不需要常变化，业务扩展有限，减少复杂度 
扩展方式 ： 抽象外观类，实现抽象外观接口

【版本控制】 ： 对其进行版本外观类，适用于 抽象外观类 ？？

### 源码应用

spring jdbc

JdbcUtils 
closeConnection 
closeStatement 
closeResultSet(rs) 
getResultSetValue(rs, index, requiredType)

- boolean.class, byte.class
- String.class
- Date.class
- java.sql.Timestamp.class
- BigDecimal

Configuration 
ibatis.session

- newMetaObject(obj)
- newParameterHandler(..)
- newResultSetHandler(executor,
- newStatementHandler

RequestFacade 
tomcat 
实际使用

- getParameter
- getParameterMap
- getServletPath
- getContextPath

Request 
calaina 
组合 RequestFacade

ResponseFacade

StandardSessionFacade

StatementFacade 
连接池提供





## 享元模式

提供减少对象数量从而改善应用所需的对象结构的方式；

运用共享技术有效地支持大量细粒度的对象；



**源码**

（1） IntegerCache(J)

缓存了 -128~127 中的数字

Redis 中通过引用计数法缓存了 0 ~ 9999 的值，从而能够支持 SkipList 的



定义：提供了【减少对象数量】从而改善应用所需的对象结构的方式 
运用【共享】技术有效地支持大量细粒度的对象

适用场景 ：

- 常应用于系统底层的开发，以便解决系统的性能问题。
- 系统有大量【相似对象】、需要缓冲池的场景

Java 中的 String ：字符串的缓存池，没有 ==> 创建，放入 Cache， 
有 ==> 取出

数据库的连接池 ：需要时直接取出

享元模式的内部化和外部化

优点 ：

- 减少对象的创建，降低内存中对象的数量，【降低系统的内存】，提高效率
- 减少内存之外的其他资源占用

缺点 ：

- 关注【内/外部】状态、关注【线程安全】问题
- 使系统、程序的逻辑复杂化

Integer 的 Cache

扩展 ： 
内部状态 ： 在享元对象内部，不会随着享元对象改变而改变的共享部分， 
享元对象的属性 
外部状态 ：随着环境改变而改变的 
不可共享

相关设计模式 ： 
与代理模式 ： 代理代理一个类，生成代理类需要花费的资源和时间多，使用享元模式提供程序的处理速度 
与单例模式 ： 容器单例 ： 享元模式与单例模式的结合 
享元模式复用对象的思想

### 源码应用

Integet.valueOf() 
IntegerCache 
LongCache

GenericObjectPoolConfig 
org.apache.commons.pool.impl 
GenericKeyedObjectPool

- borrowObject(key) ObjectDeque





## 组合模式

composite 
定义：将对象组合成树形结构以表示【"部分·整体"】的层次结构 
组合模式使客户端对单个对象和组合对象保持一致的方式处理

树形结构的菜单 ： 菜单中含有子菜单，子菜单含有子菜单 
目录 ：下面可能有目录 or 文件

使用【树形结构】的方式创建

适用场景 ：

- 希望客户端可以忽略组合对象与单个对象的差异时
- 处理一个树形结构时

优点 ：

- 清楚地定义【分层次】的复杂对象，表示对象的全部或部分层次
- 让客户端忽略了层次的差异，方便对整个层次结构进行控制
- 简化客户端代码
- 符合开闭原则

缺点 ：

- 限制类型时会较为复杂
- 使设计变得更加抽象

某个文件夹中只能包含文本文件，使用组合模式不能利用类型系统来施加这些约束 
都来自相同的抽象层，node 
必须通过运行时类型检查实现，从而变得负责

相关模式 ： 
与访问者模式 ： 组合应用 ： 使用访问者模式访问组合模式中的递归结构





### 应用

目录 - 抽象组件 
课程 
课程目录 Java, Python

对于入参和返回值根据实际的业务抽象

组合模式核心 ： add 方法填充课程 或 目录，将其视作一个对象，减少这两个对象在使用时候的差异

动态地对类型进行限制会使业务逻辑复杂 ==> 动态类型的判断

对于最上层的抽象组件确定好参数和返回值注意 
重写方法时确定哪些符合业务逻辑，目录下面还含有目录，深层次的递归

解决方案 ： 
增减 Level 属性来实现 
类型判断

组合模式 ： 将多个对象组合成一个对象，简化对多个对象的访问 
最关键 ： 叶子对象和组合对象都要实现【相同的接口或继承相同的抽象类】， 才能够将叶子节点对象和组合好的对象节点进行统一的处理

### 源码使用

Container 
java.awt 
通过行为方法进行识别，将相同的抽象类的类型或接口的类型的实例转换成树状结构 
add 增加父类 Component

HashMap 
putAll(map)



ArrayList 
addAll(coll)

*SqlNode I 
mybatis

- apply(DynamicContext) 
  MixedSqlNode implement SqlNode
- List

WhereSqlNode extends TrimSqlNode



## 桥接模式

定义：将抽象部分与它的具体实现部分分离，使它们都可以独立地变化

通过【组合】的方式建立两个类之间联系，而不是继承

通过桥接模式使两个不同的类建立联系 
防止子类爆炸

通过桥接模式实际跨平台可以播放多种视频格式的播放器

适用场景 ： 
抽象和具体实现之间增加更多的灵活性

一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展

不希望使用继承，或因为多层继承导致系统类的个数剧增

优点 ：

- 【分离抽象及其具体】实现部分
- 提高了系统的可扩展性
- 符合开闭原则
- 符合合成复用原则

缺点 ：

- 增加了系统的理解与设计难度
- 需要正确地识别出系统中两个独立变化的维度

适用范围局限

小坑 ： 【委托】 给 "同名" 的方法，具体的行为委托

相关模式 ： 
与组合模式 ： 
组合模式强调部分和整体之间的组合，桥接模式强调平行级别上不同类的组合

适配器模式 ： 都是为了两个配合工作 
目的不同 ：适配器模式改变已有的接口，使两者之间可以相互配合 
桥接模式分离抽象和具体实现，目的是分离

### 应用

将抽象和实现分离出来，通过组合搭建两者之间的桥梁，连接两个继承体系的桥梁 
抽象部分和实现部分可独立的扩展

ACBC

随着自己的层级不断向下扩展

委托关系

抽象类 Bank 实现了 Account 接口，通过组合方式 
连接两个继承体系的一座桥

也有通过聚合方式实现桥接

桥接模式在一定长度上避免子类过多 
多个银行中的多个定期和活期账户 
各自独立扩展，发展 





### 源码应用

Driver I 
DriverManager

- registerDrivers
- getConnection(url, user, password)

DriverInfo 
通过桥接模式，只需要修改 Driver 加载的类即可 
Oracle，Mysql 的实现 ==> 开闭原则

DriverManage 与具体的 Driver(DriverInfo) 之间实现了桥接模式



# 行为型(11)

## 模板方法模式

定义了算法的骨架，允许子类为一个或多个步骤提供实现，类似算法的函数。



主要通过继承实现的。



（） 使用场景

一次性实现算法的不变部分，并将可变的行为留给子类来实现；



（） 钩子方法



## 策略模式

**源码**

（1） AbstractList

抽取出不变的行为，具体的交给





（2） HttpServlet

doGet

doPost

service



## 观察者模式

定义对象之间的一对多依赖，让多个观察者同时监听某一个主题对象，当主题对象发生变化时，它的依赖者（观察者） 都会受到并更新；



（） 适用场景

关联行为场景，建立一套触发机制



## 状态模式

角色控制，实现一个工作者 由  Enginner ⇒ Manager





## 迭代器模式





[spring 官网](http://spring.io/projects)

[spring JPA](https://spring.io/projects/spring-data-jpa)







多线程 Debug
[下载](https://varaneckas.com/jad/)



JAD 反编译工具


```
jad EnumInstance.class
```









asm 生成字节码
logbok 通过 asm 字节码生成
spring 分库 









对象生成的几种方式
new 
clone 内存中的字节流
反射
序列化，asm 字节码，持久化文件到对象



 





一些写法

对于不变部分的行为通过 final 修饰

对于不同行为，通过 钩子函数来确定



通过继承体系结构访问父类，定义 protected 访问权限的属性


对 Null 的特殊处理 ：
策略模式中的 EmptyStrategy
解释器模式中 EmptyInterceptor
责任链模式中对下一个链条的空判断



this 作为一些情况的特殊处理 ：
传递自身功能给方法

```java
class DProxy 
	implements InvocationHandler {
    Object target;
    void bind() {
    	Class<?> cls = target.getClass();
        Proxy.newInstance(cls.getCLassLoader(), cls.getInterfaces(), this);
    }
    
    @Override
    
    Object invoke(Proxy proxy, Method method, Object[] args) {}
}
```





一些概念和总结：

通过【分离】来解耦的 ： 
桥接模式 ：
分离抽象与具体，两个不同继承体系

访问者模式 ： 数据结构与数据操作分离

迭代器模式 ： 存储与遍历分离

构建器模式 ： 创建和使用分离

责任链模式 ： 请求的发送者和接受者jieou

命令模式 ： 通过请求调用者和接受者解耦，使得调用者和接受者不直接交互



可能造成类数量过多的模式 ：
命令模式
状态模式





通过 【合成】 来【复用】减少类的 ： 
享元模式
单例模式





一些机制 ：
触发机制 ： 观察者模式
可恢复机制 ： 备忘录模式




与业务耦合性高的 ： 
备忘录模式 ： 
访问者模式 ： 编译器
状态模式 ： 状态机




钩子函数 ： 
定义不同的实
